name: Docker CD

on:
  workflow_run:
    workflows: ["Docker CI"]
    types: [completed]

concurrency:
  group: docker-cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy to Server
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (infra files)
        uses: actions/checkout@v4

      # Upload compose + nginx (and scripts) to the VPS
      - name: Copy infra to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: 22
          source: |
            infra/docker-compose.yml
            infra/nginx/**
            infra/scripts/**
          target: /opt/app/

      - name: Deploy via SSH (docker compose, nginx, 3 replicas)
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: 22
          debug: true
          script_stop: true
          script: |
            set -Eeuo pipefail
            echo "Starting deployment…"
            cd /opt/app

            # Ensure docker & compose exist
            docker --version
            docker compose version

            # Optional: Login to Docker Hub if your repo is private
            if [ -n "${{ secrets.DOCKER_HUB_ACCESS_TOKEN || '' }}" ]; then
              echo "${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}" | docker login \
                -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
            fi

            # Substitute your Docker Hub image into compose (if your compose uses a placeholder)
            # This replaces __DOCKER_HUB_IMAGE__ with <username>/admin-app:latest
            if grep -q "__DOCKER_HUB_IMAGE__" docker-compose.yml; then
              sed -i "s|__DOCKER_HUB_IMAGE__|${{ secrets.DOCKER_HUB_USERNAME }}/admin-app:latest|g" docker-compose.yml
            fi

            # If you passed DOMAIN as a secret, stamp it into nginx vhost
            if [ -n "${{ secrets.DOMAIN || '' }}" ]; then
              sed -i "s/api\\.example\\.com/${{ secrets.DOMAIN }}/g" nginx/conf.d/app.conf || true
              sed -i "s/www\\.api\\.example\\.com/www.${{ secrets.DOMAIN }}/g" nginx/conf.d/app.conf || true
            fi

            # Pull the latest images referenced by compose
            docker compose pull || true

            # Bring up Nginx and a single app first (so HTTP-01 challenge can work on first run)
            # If you don't use TLS, it's still fine.
            docker compose up -d nginx express-app-admin-1

            # If DOMAIN is set, try issuing TLS certs on first run (skips if already present)
            if [ -n "${{ secrets.DOMAIN || '' }}" ]; then
              CERT_BASE="/var/lib/docker/volumes/infra_certbot-certs/_data/live/${{ secrets.DOMAIN }}"
              if [ ! -d "$CERT_BASE" ]; then
                echo "Issuing Let's Encrypt cert for ${{ secrets.DOMAIN }}…"
                docker compose run --rm certbot certbot certonly \
                  --webroot -w /var/www/certbot \
                  -d "${{ secrets.DOMAIN }}" -d "www.${{ secrets.DOMAIN }}" \
                  --email "${{ secrets.LETSENCRYPT_EMAIL }}" --agree-tos --no-eff-email || true
                docker compose restart nginx || true
              fi
            fi

            # Start / update all three app replicas
            docker compose up -d express-app-admin-1 express-app-admin-2 express-app-admin-3

            # Reload Nginx (and optionally render upstreams if you use a script)
            if [ -f scripts/render_upstream.sh ]; then
              chmod +x scripts/render_upstream.sh
              bash scripts/render_upstream.sh || docker compose exec -T nginx nginx -s reload || true
            else
              docker compose exec -T nginx nginx -s reload || true
            fi

            echo "Deployment complete ✅"
