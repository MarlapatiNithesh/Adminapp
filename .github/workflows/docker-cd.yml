name: Docker CD

on:
  workflow_run:
    workflows: ["Docker CI"]
    types: [completed]

concurrency:
  group: docker-cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy to Server
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (infra files)
        uses: actions/checkout@v4

      # Upload compose + nginx (and scripts) to the VPS
      - name: Copy infra to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: 22
          source: |
            infra/docker-compose.yml
            infra/nginx/**
            infra/scripts/**
          target: /opt/app/

      - name: Deploy via SSH (docker compose + 3 replicas + optional TLS)
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: 22
          debug: true
          script_stop: true
          script: |
            set -Eeuo pipefail
            echo "Starting deployment…"
            cd /opt/app

            # Ensure Docker & compose
            docker --version
            docker compose version

            # Login to Docker Hub if repo is private (optional)
            if [ -n "${{ secrets.DOCKER_HUB_ACCESS_TOKEN || '' }}" ]; then
              echo "${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}" | docker login \
                -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
            fi

            # If your compose uses a placeholder for the image, replace it
            # Example placeholder: __DOCKER_HUB_IMAGE__
            if [ -f docker-compose.yml ] && grep -q "__DOCKER_HUB_IMAGE__" docker-compose.yml; then
              sed -i "s|__DOCKER_HUB_IMAGE__|${{ secrets.DOCKER_HUB_USERNAME }}/admin-app:latest|g" docker-compose.yml
            fi

            # If you pass a DOMAIN secret, stamp it into nginx vhost once
            if [ -n "${{ secrets.DOMAIN || '' }}" ]; then
              sed -i "s/api\\.example\\.com/${{ secrets.DOMAIN }}/g" nginx/conf.d/app.conf || true
              sed -i "s/www\\.api\\.example\\.com/www.${{ secrets.DOMAIN }}/g" nginx/conf.d/app.conf || true
            fi

            # Pull latest images referenced by compose (ignores local build if image set)
            docker compose pull || true

            # Start Nginx and at least one app for HTTP (and ACME challenge if using TLS)
            docker compose up -d nginx express-app-admin-1

            # FIRST RUN ONLY: Issue Let's Encrypt certs if DOMAIN provided
            if [ -n "${{ secrets.DOMAIN || '' }}" ]; then
              CERT_BASE="/var/lib/docker/volumes/infra_certbot-certs/_data/live/${{ secrets.DOMAIN }}"
              if [ ! -d "$CERT_BASE" ]; then
                echo "Issuing TLS cert for ${{ secrets.DOMAIN }}…"
                docker compose run --rm certbot certbot certonly \
                  --webroot -w /var/www/certbot \
                  -d "${{ secrets.DOMAIN }}" -d "www.${{ secrets.DOMAIN }}" \
                  --email "${{ secrets.LETSENCRYPT_EMAIL }}" --agree-tos --no-eff-email || true
                docker compose restart nginx || true
              fi
            fi

            # Ensure all three replicas are up
            docker compose up -d express-app-admin-1 express-app-admin-2 express-app-admin-3

            # If you use a dynamic upstreams script, run it; else just reload Nginx
            if [ -f scripts/render_upstream.sh ]; then
              chmod +x scripts/render_upstream.sh
              bash scripts/render_upstream.sh || docker compose exec -T nginx nginx -s reload || true
            else
              docker compose exec -T nginx nginx -s reload || true
            fi

            echo "Deployment complete ✅"
